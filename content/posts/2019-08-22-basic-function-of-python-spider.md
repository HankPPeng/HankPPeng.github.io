---
title: Basic function of Python-Spider
author: ''
date: '2019-08-22'
slug: basic-function-of-python-spider
categories: []
tags:
  - Study
description: ''
externalLink: ''
series: []
---
&emsp;最近重温Python的内容，在我实际的应用中，用的比较多的是 `import...` 和 `def ...`，在记住一些基本的语法规则以后就可以在一些场合比较好地使用Python。近日也突发奇想，用爬虫来抓取某网站的电影数据，之后将数据推送到自己的设备上面，虽然现在也存在着一些App能够做到这种功能，不过自定义程度不够高，希望学习一下能够满足自己的小小愿望。

&emsp;经过自己尝试编写简单的Pyhton-Spider发现，经常用到的需要进行学习的有以下三项：正则表达式`re`，请求`requests`，规范超文本语句`lxml`。以上三项都是Python中的库，能够调取使用，在这里稍稍地整理一下，以防日后忘记用法。

* 正则表达式`re`

&emsp;接触到了正则表达式之后才发现自己以前都太不懂搜索了，正则表达式就是通过一连串繁琐的字符（当然也可以很简单）来匹配文本，这会想起Word里边的‘查找与替换’，不过，以前我都是输入一个特定的字符然后进行另外一个字符的替换，这放在短文本里边是完全没有问题的，与其输入繁琐的正则表达式，倒不如输入特定的字符。可是，自己写爬虫的时候，用正则表达式提取数据就非常高效了，怎么高效只有自己知道，下面解释一个典型正则表达式的意思：

```
\(?0\d{2}[) -]?\d{8}
```

&emsp;这个表达式我看解释的时候就觉得：嗯，原来就是这么回事啊。啃了教程之后回头看，自己写出来可不容易啊...Ok，这个表达式的意思是（我将它进行拆分）：

  * `\(?`表出现0次或1次；`0`匹配0；
  * `\d{2}`表出现两个随机数字（0-9）；
  * `[) -]?`表`)`，`空格`，`-`中任意一个字符出现0次或1次；
  * `\d{8}`表出现8个随机数字。

&emsp;看吧，其实遵循一些规则，要理解正则表达其实也挺简单的。下面我对自己的笔记进行整理：

  * 正则表达式：一种文本模式，通常为普通字符+元字符组成。
  
  * 硬盘下通配符：`?`通配文件名中0或1个字符；`*`通配文件名的0个或多个字符。
  
  * 语法：个人觉得一个正确的正则表达式的语法应该包括字符，运算优先级和匹配规则。这其中的字符是繁琐的，留在后面整理，先对运算优先级和匹配规则做整理。
  
    * 运算优先级：遵循“从左到右，先高后低”的原则，其实就是整个式子是“从左往右”匹配，当遇到高级的运算符的时候先解释高级的再到低级的。下面按照由高到低的顺序排列运算符：
      * `\`：转义符。
      * `(), []`：圆括号和方括号。
      * `*, +, ?, {}`：限定符。
      * `^, $, \任意字符, 任意字符`：位置顺序。
      * `|`：替换，“或”操作符。
      
    * 匹配规则：出现即匹配。这其中`{1}`表出现一次，`{1,2}`表出现1次或2次，`{1,}`表出现1次或以上。
    
    * 字符：正则表达式描述了一种字符串匹配的模式，可以用来检查一个字串是否含有某种字子串、将匹配的子字串替换或提取出符合匹配条件的子字串等。
    
      * 普通字符：包括所有未显式指定为元字符的所有可打印和不可打印的字符，简单地说，也就是没有被指定为特殊意思的字符，这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符，像C里边的`\n`就是指定为`换行`意思的字符。
      
      * 非打印字符：不进行打印的字符，有其特殊的表达含义：
          * `\cx`：匹配由`x`指明的控制字符，如`\cI`匹配一个水平制表符`\t`，`\cJ`匹配一个换行符`\n`,`\cM`匹配一个回车符`\r`等等。
          * `\f`：匹配一个换页符。
          * `\n`：匹配一个换行符。
          * `\r`：匹配一个回车符。
          * `\s`：匹配任何空白字符，包括空格、制表符、换页符等等，等价于 `[\f\n\r\t\v]`。
          * `\S`：匹配任何非空白字符。
          * `\t`：匹配一个制表符。
          * `\v`：匹配一个垂直制表符。
          
      * 特殊字符：在字符串中存在特殊意义，若需显示则需要在前面添加转义字符`\`。
          * `^`：匹配输入字符串的开始位置；若其在方括号中则表示“非”的意思，即不匹配方括号中的字符串。
          * `$`：匹配输入字符串的结尾位置。
          * `( )`：匹配括号中的字符串；**子表达式可以获取供以后使用**。
          * `[ ]`：匹配括号中的字符的任意一个或范围，如`[03]`表匹配0或者3，`[0-3]`表匹配0到3四个数字中的一个。
          * `{ }`：匹配前面字符出现的长度（次数）。
          * `?`：匹配前面子表达式0次或1次。
          * `*`：匹配前面子表达式0次或多次。
          * `+`：匹配前面子表达式1次或多次。
          * `.`：	匹配除换行符`\n`之外的任何单字符。
          * `|`：指明两项之间的一个选择。
          
      上面差不多是主要的字符，还有将以上字符进行分类的，如定位符，限定符等，但是这些分类也离不开上面的字符，所以在这里不多列举。下面将完整的有着特殊含义的字符附上：来源于[菜鸟教程](https://www.runoob.com/regexp/regexp-metachar.html)。
      
      ![元字符](https://github.com/HankPPeng/HankPeng.com/blob/master/images/%E5%85%83%E5%AD%97%E7%AC%A6.png?raw=true)
      
  * 下面总结在Python下怎么使用正则表达式：
    * 需要在导言区导入：`import re`。
    * 具体的语句有：
      * `re.match(pattern, string, flags)`：其中，`pattern`是正则表达式；`string`是需进行匹配的文本或字符串；`flags`是可选参数（最后总结）；这个语句的意思是在`string`的开始位置开始匹配，若不匹配则返回`None`，也就是`pattern`需要与`string`开头一致才会进行匹配。用`.group()`查看匹配结果。
      * `re.search(pattern, string, flags)`：这个语句相对于`re.match()`来说无需开头一致，查找整个文本或字符串。它们之间的区别在于：`re.match`只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回`None`；而`re.search`匹配整个字符串，直到找到一个匹配。
      * `re.sub(pattern, repl, string, count=0, flags=0)`：`repl`是替换的字符串，也可为一个函数；`count`是模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。
      * `re.compile(pattern, flags)`：`pattern`是一个字符串形式的正则表达式。生成一个正则表达式对象，能够供`re.match`和`re.research`调取使用，最大的好处是能够指定要匹配字符串的位置进行匹配。
      * `re.findall(pattern, string, pos, endpos)`：`pos`是可选参数，指定字符串的起始位置，默认为 0;`endpos`是可选参数，指定字符串的结束位置，默认为字符串的长度。这语句是匹配字符串中所有的正则表达式，而`match`和`search`匹配一次后不再匹配。
      * `re.finditer(pattern, string, flags=0)`：表示在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。
      * `re.split(pattern, string, maxsplit=0, flags=0)`：`maxsplit`是分割次数，`maxsplit=1`为分割一次，默认为0不限次数。这个语句按照匹配的子串将字符串分割后返回列表。
      * `flags`：
          * `re.I`：使匹配对大小写不敏感；
          * `re.L`：做本地化识别（locale-aware）匹配；
          * `re.M`：多行匹配，影响`^`和`$`；
          * `re.S`：使`.`匹配包括换行在内的所有字符；
          * `re.U`：根据Unicode字符集解析字符。这个标志影响 `\w, \W, \b, \B`；
          * `re.X`：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。
          
* 请求`requests`